<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>

        // //人的对象
        // var person = new Object();
        // person.name = "小白";
        // person.age = 10;
        // person.sayHi = function () {
        //     //在当前这个对象的方法中是可以通过this.访问当前这个对象的属性的值
        //     //这ava就算不加this.也可以访问属性值（加this是重名时用的）
        //     //js这里和Java稍有不同，如果通过系统构造函数new Object来创建对象，
        //     //js若想访问本对象的属性必须要加this，否则是访问不到的。
        //     console.log("您好,吃了没您,我叫:" + this.name);
        // };
        //
        //
        // // 学生的对象
        // var stu = new Object();
        // stu.name = "小芳";
        // stu.age = 18;
        // stu.study = function () {
        //     console.log("学习,敲代码,今天作业四遍,我今年" + this.age + "岁了");
        // };
        //
        //
        // //    //小狗的对象
        // var dog = new Object();
        // dog.name = "哮天犬";
        // dog.say = function () {
        //     console.log("汪汪...我是哮天犬");
        // };
        //
        //
        // 和java中一样，可以通过instanceof关键字判断对象的类型
        // 输出人是不是人的类型
        // console.log(person instanceof Object);
        // console.log(stu instanceof Object);
        // console.log(dog instanceof Object);

    </script>
    <script>
        // 上述使用Object()构造函数创建对象有一个弊端，就是复用性不强。
        // 例如我们创建了小白这个人，如果再想创建大白，就必须重新再new Object()创建一次。
        // 此时我们可以使用工厂模式创建对象来提高复用性

        function createPerson(name, age) {
            var person = new Object();
            person.name = name + "aa";  // 测试不加下面不加this.，获取到的是哪个参数
            person.age = age;
            person.say = function () {
                // 工厂方式创建对象的方式，就算不用this.也能访问到属性，因为这里传入了参数name
                // 如果我们不加this.(person.也可以)，那么获取到的是参数传进来的name。
                console.log("我的名字叫" + person.name + ",今年" + this.age + "岁了。")
            };
            return person;
        }

        var person1 = createPerson("张三", 18);
        person1.say();

        var person2 = createPerson("李四", 28);
        person2.say();
    </script>
</head>
<body>

</body>
</html>